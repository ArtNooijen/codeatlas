"""Create review branches and PRs for documentation review."""
from __future__ import annotations

import json
import time
from pathlib import Path
from urllib.parse import urlparse

import httpx
import pygit2  # type: ignore
from rich.console import Console

from ..ingest.git_repo import RepoInfo

console = Console()


class ReviewManager:
    """Manages review branch creation and PR workflow for documentation."""

    def __init__(self, repo_info: RepoInfo) -> None:
        self.repo_info = repo_info
        self.repo = pygit2.Repository(str(repo_info.path))
        self.token = repo_info.token
        self.session = httpx.Client(timeout=30)
        if not self.token:
            raise RuntimeError("GitHub token required for PR creation")

    def create_review_branch(self, branch_suffix: str | None = None) -> str:
        """Create a new branch for documentation review."""
        if branch_suffix:
            branch_name = f"docs/auto-{branch_suffix}"
        else:
            timestamp = int(time.time())
            branch_name = f"docs/auto-generated-{timestamp}"

        # Get current HEAD
        head = self.repo.head
        head_commit = head.peel(pygit2.Commit)

        # Create new branch
        branch_ref = f"refs/heads/{branch_name}"
        self.repo.create_reference(branch_ref, head_commit.id)

        # Checkout the new branch
        self.repo.checkout(branch_ref)
        console.print(f"[green]Created and checked out review branch: {branch_name}")
        return branch_name

    def create_review_pr(
        self,
        branch_name: str,
        title: str | None = None,
        body: str | None = None,
        documented_files: list[str] | None = None,
    ) -> str | None:
        """Create a GitHub PR for documentation review."""
        # Create PR in the fork repository (where we're working)
        # The fork_url tells me where the fork is
        parsed = urlparse(self.repo_info.fork_url)
        if parsed.netloc == "github.com":
            parts = parsed.path.strip("/").split("/")
            if len(parts) >= 2:
                owner = parts[0]
                repo = parts[1]
            else:
                owner, repo = self.repo_info.fork_owner, self.repo_info.repo_name
        else:
            owner, repo = self.repo_info.fork_owner, self.repo_info.repo_name
        
        base_branch = self.repo_info.branch

        if not title:
            title = f"docs: Auto-generated documentation review"

        if not body:
            body_lines = [
                "## Auto-Generated Documentation",
                "",
                "This PR contains automatically generated documentation. Please review the changes below.",
                "Click the files changed tab to see the proposed documentation updates.",
                "If everything looks good, approve and merge this PR to finalize the documentation.",
            
            ]
            if documented_files:
                body_lines.extend([
                    "",
                    "### Documented Files:",
                    "",
                ])
                for file_path in documented_files[:50]:  # Limit to 50 files
                    body_lines.append(f"- `{file_path}`")
                if len(documented_files) > 50:
                    body_lines.append(f"\n... and {len(documented_files) - 50} more files")
            
            body_lines.extend([
                "",
                "### Review Instructions:",
                "",
                "1. Review the generated documentation",
                "2. Make any necessary edits",
                "3. Approve and merge this PR to finalize the documentation",
                "",
                "---",
                "*Generated by CodeAtlas*",
            ])
            body = "\n".join(body_lines)

        api_url = f"https://api.github.com/repos/{owner}/{repo}/pulls"
        headers = {
            "Authorization": f"Bearer {self.token}",
            "Accept": "application/vnd.github+json",
        }
        
        # Since we're creating PR in the fork repo, head is just the branch name
        payload = {
            "title": title,
            "body": body,
            "head": branch_name,
            "base": base_branch,
        }

        try:
            console.print(f"[cyan]Creating PR in {owner}/{repo} with head={branch_name}, base={base_branch}")
            resp = self.session.post(api_url, json=payload, headers=headers)
            if resp.status_code in (201, 200):
                pr_data = resp.json()
                pr_url = pr_data.get("html_url")
                pr_number = pr_data.get("number")
                console.print(f"[green]Created PR #{pr_number}: {pr_url}")
                return pr_url
            else:
                error_data = resp.json() if resp.text else {}
                console.print(f"[red]Failed to create PR: {resp.status_code}")
                console.print(f"[red]Error details: {error_data}")
                console.print(f"[yellow]Payload was: head={branch_name}, base={base_branch}, repo={owner}/{repo}")
                return None
        except Exception as exc:
            console.print(f"[red]Error creating PR: {exc}")
            return None

    def push_review_branch(self, branch_name: str) -> bool:
        """Push the review branch to remote."""
        remote = self._origin_remote()
        if remote is None:
            console.print("[yellow]No origin remote configured; skipping push.")
            return False

        callbacks = None
        if self.token:
            credentials = pygit2.UserPass(self.token, "x-oauth-basic")
            callbacks = pygit2.RemoteCallbacks(credentials=credentials)

        try:
            refspec = f"refs/heads/{branch_name}:refs/heads/{branch_name}"
            remote.push([refspec], callbacks=callbacks)
            console.print(f"[green]Pushed branch {branch_name} to origin")
            return True
        except Exception as exc:
            console.print(f"[red]Failed to push branch: {exc}")
            return False

    def _origin_remote(self) -> pygit2.Remote | None:
        """Get the origin remote."""
        for remote in self.repo.remotes:
            if remote.name == "origin":
                return remote
        return None

